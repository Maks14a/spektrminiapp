<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>СПЕКТР</title>

    <link rel="stylesheet" href="styles.css" />

    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        /* затемнение фона */
        .dikidi-modal {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            margin: 0;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s ease;
        }
        .dikidi-modal.show {
            opacity: 1;
            pointer-events: auto; /* Реагирует на события, когда показан */
        }

        /* сам «поп‑ап»: адаптивный iframe */
        .dikidi-iframe {
            width: 100vw;
            height: 100vh;
            max-width: 100%;
            max-height: 100%;
            border: none;
            border-radius: 0px;
            background: #fff;
            opacity: 0;
            transition: opacity 0.4s ease;
            box-sizing: border-box;
        }
        .dikidi-iframe.loaded {
            opacity: 1;
        }

        /* крестик закрыть */
        .dikidi-close {
            position: absolute;
            top: 18px;
            right: 22px;
            font-size: 36px;
            color: #fff;
            cursor: pointer;
            user-select: none;
            line-height: 1;
        }

        /* Стили для лоадера */
        .dikidi-loader {
            border: 8px solid #555; /* Темно-серый для тела круга */
            border-top: 8px solid rgb(240, 191, 76); /* Оранжевый RGB: 240, 191, 76 для вращающейся части */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 2s linear infinite;
            position: absolute; /* Position over the iframe area */
            z-index: 2001; /* Ensure it's above the modal background but below close button */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>

<body>
    <div id="intro-screen">
        <video id="intro-video" autoplay muted playsinline preload="auto">
            <source src="превью.mp4" type="video/mp4" />
            Ваш браузер не поддерживает видео.
        </video>
    </div>

    <div class="container" id="main-content">
        <img src="logo2.png" alt="СПЕКТР" class="logo" />
        <div class="buttons">
            <button id="show-appointment-btn" class="btn btn-primary">ЗАПИСАТЬСЯ</button>
            <button id="show-events-btn" class="btn btn-outline">ЕВЕНТЫ</button>
        </div>

        <img src="noti.jpg" alt="ноты" class="circle-img circle1" />
        <div class="circle-text circle1-text">Здесь будут буковы</div>

        <img src="microphone.jpg" alt="микрофон" class="circle-img circle2" />
        <div class="circle-text circle2-text">Здесь будут буковы</div>
    </div>

    <div class="container" id="appointment-screen">
        <div class="back-button" id="back-to-main-from-appointment"></div>

        <div class="appointment-layout-grid">
            <div class="grid-text">ТУТ ТЕКСТ</div>
            <div class="grid-text">ТУТ ТЕКСТ</div>

            <div class="image-circle"><img src="microphone.jpg" alt="микрофон" /></div>
            <div class="image-circle"><img src="microphone.jpg" alt="микрофон" /></div>

            <button id="dikidi-book-btn" class="btn btn-yellow grid-button">ЗАПИСАТЬСЯ</button>

            <div class="image-circle"><img src="microphone.jpg" alt="микрофон" /></div>
            <div class="image-circle"><img src="microphone.jpg" alt="микрофон" /></div>

            <div class="grid-text">ТУТ ТЕКСТ</div>
            <div class="grid-text">ТУТ ТЕКСТ</div>
        </div>

        <img src="logo3.png" alt="Логотип" class="footer-logo" />
    </div>

    <div class="container" id="events-screen">
        <div class="back-button" id="back-to-main-from-events"></div>

        <div class="events-carousel-wrapper">
            <div class="events-carousel" id="events-carousel">
                </div>
        </div>

        <div class="events-pagination" id="events-pagination"></div>
        <img src="logo3.png" alt="Логотип" class="footer-logo-static" />
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {

        /* ---------- DOM Element References ---------- */
        const introScreen = document.getElementById('intro-screen');
        const introVideo = document.getElementById('intro-video');
        const mainContent = document.getElementById('main-content');
        const appointmentScreen = document.getElementById('appointment-screen');
        const eventsScreen = document.getElementById('events-screen');
        const showAppointmentBtn = document.getElementById('show-appointment-btn');
        const showEventsBtn = document.getElementById('show-events-btn');
        const backToMainFromAppointmentBtn = document.getElementById('back-to-main-from-appointment');
        const backToMainFromEventsBtn = document.getElementById('back-to-main-from-events');
        const eventsCarousel = document.getElementById('events-carousel');
        const eventsPagination = document.getElementById('events-pagination');
        const allScreens = [mainContent, appointmentScreen, eventsScreen];

        /* =================================================================
           BUG FIX: Centralized function to handle screen transitions
           This prevents multiple screens from having the 'show' class at
           the same time, fixing the overlap issue.
           ================================================================= */
        function switchScreen(screenToShow) {
            allScreens.forEach(screen => {
                // Remove 'show' from all screens except the target one
                if (screen !== screenToShow) {
                    screen.classList.remove('show');
                }
            });
            // Add 'show' to the target screen
            screenToShow.classList.add('show');
        }

        /* ---------- Screen Transition Logic ---------- */
        introVideo.addEventListener('ended', () => {
            introScreen.classList.add('hidden');
            switchScreen(mainContent);
        });

        const playPromise = introVideo.play();
        if (playPromise !== undefined) {
            playPromise.catch(error => {
                console.error("Autoplay was blocked:", error);
                introScreen.classList.add('hidden');
                switchScreen(mainContent);
            });
        }

        // Fallback timer in case the 'ended' event doesn't fire
        setTimeout(() => {
            if (!mainContent.classList.contains('show')) {
                console.warn("Intro seems stuck, forcing main screen.");
                introScreen.classList.add('hidden');
                switchScreen(mainContent);
            }
        }, 5000); // 5 seconds

        showAppointmentBtn.onclick = () => switchScreen(appointmentScreen);

        showEventsBtn.onclick = () => {
            switchScreen(eventsScreen);
            loadEvents(); // Load events when switching to the screen
        };

        backToMainFromAppointmentBtn.onclick = () => switchScreen(mainContent);
        backToMainFromEventsBtn.onclick = () => switchScreen(mainContent);

        /* =================================================================
           PAGINATION FIX: Improved correlation between dots and slides
           ================================================================= */

        // Helper to calculate the width of a single carousel item including its gap
        function getSlideStep() {
            if (eventsCarousel.children.length > 1) {
                const firstItem = eventsCarousel.children[0];
                const secondItem = eventsCarousel.children[1];
                return secondItem.offsetLeft - firstItem.offsetLeft;
            }
            return eventsCarousel.clientWidth; // Fallback for single item
        }

        function createDots() {
            eventsPagination.innerHTML = '';
            const total = eventsCarousel.children.length;
            if (total === 0) return;

            const slideStep = getSlideStep(); // Get the width of one step

            for (let i = 0; i < total; i++) {
                const dot = document.createElement('span');
                dot.className = 'pagination-dot';
                dot.addEventListener('click', () => {
                    // Scroll to the calculated position of the target slide
                    eventsCarousel.scrollTo({ left: slideStep * i, behavior: 'smooth' });
                });
                eventsPagination.appendChild(dot);
            }
            updateDots();
        }

        function updateDots() {
            const dots = eventsPagination.querySelectorAll('.pagination-dot');
            if (eventsCarousel.children.length === 0) {
                dots.forEach(dot => dot.classList.remove('active'));
                return;
            }

            const slideStep = getSlideStep();
            if(slideStep === 0) return;

            // Calculate active index based on the actual slide width
            const activeIndex = Math.round(eventsCarousel.scrollLeft / slideStep);
            dots.forEach((dot, index) => {
                dot.classList.toggle('active', index === activeIndex);
            });
        }
        eventsCarousel.addEventListener('scroll', updateDots, { passive: true });


        /* ---------- Events Loading Logic ---------- */
        const API_STATIC = "https://api-clear79.amvera.io/static/";
        const API_FILES = "https://api-clear79.amvera.io/files";

        async function loadEvents() {
            try {
                const filesResponse = await fetch(API_FILES);
                if (!filesResponse.ok) throw new Error(`HTTP error! status: ${filesResponse.status}`);
                const filesData = await filesResponse.json();
                const mediaFiles = filesData.files.filter(filename =>
                    filename.match(/\.(jpeg|jpg|gif|png|webp|avif|mp4)$/i)
                ) || [];

                eventsCarousel.innerHTML = '';

                if (mediaFiles.length > 0) {
                    mediaFiles.forEach(filename => {
                        const mediaUrl = `${API_STATIC}${filename}`;
                        const fileExtension = filename.split('.').pop().toLowerCase();
                        const isVideo = fileExtension === 'mp4';

                        const eventDiv = document.createElement('div');
                        eventDiv.className = 'event-card';

                        let mediaElementHtml;
                        if (isVideo) {
                            mediaElementHtml = `<video src="${mediaUrl}" class="event-image" autoplay loop muted playsinline></video>`;
                        } else {
                            mediaElementHtml = `<img src="${mediaUrl}" alt="Event Image" class="event-image">`;
                        }

                        eventDiv.innerHTML = `${mediaElementHtml}`;
                        eventsCarousel.appendChild(eventDiv);
                    });
                    createDots(); // Create dots after content is loaded
                } else {
                    eventsCarousel.innerHTML = '<p class="no-events">Пока нет предстоящих событий.</p>';
                    eventsPagination.innerHTML = ''; // Clear dots if no events
                }

            } catch (error) {
                console.error('Error loading event files:', error);
                eventsCarousel.innerHTML = '<p class="error-message">Не удалось загрузить события. Попробуйте позже.</p>';
            }
        }

        /* ---------- DIKIDI Widget Logic ---------- */
        const WIDGET_URL = 'https://dikidi.ru/#widget=190962';
        const btnBook = document.getElementById('dikidi-book-btn');
        btnBook.addEventListener('click', openDikidiModal);

        function openDikidiModal() {
            if (document.querySelector('.dikidi-modal')) return;

            const modal = document.createElement('div');
            modal.className = 'dikidi-modal';

            const close = document.createElement('span');
            close.className = 'dikidi-close';
            close.textContent = '×';
            close.onclick = () => {
                modal.classList.remove('show');
                setTimeout(() => modal.remove(), 250);
            };

            const loader = document.createElement('div');
            loader.className = 'dikidi-loader';

            const frame = document.createElement('iframe');
            frame.src = WIDGET_URL;
            frame.className = 'dikidi-iframe';
            frame.allow = 'payment *; fullscreen';

            frame.style.width = `${window.innerWidth}px`;
            frame.style.height = `${window.innerHeight}px`;

            frame.onload = () => {
                loader.remove();
                frame.classList.add('loaded');
            };

            modal.appendChild(loader);
            modal.appendChild(frame);
            modal.appendChild(close);
            document.body.appendChild(modal);
            requestAnimationFrame(() => modal.classList.add('show'));
        }

        /* ---------- Carousel Dragging Logic ---------- */
        let isDown = false;
        let startX;
        let scrollLeft;

        function startDragging(e) {
            isDown = true;
            eventsCarousel.classList.add('dragging');
            startX = (e.pageX || e.touches[0].pageX) - eventsCarousel.offsetLeft;
            scrollLeft = eventsCarousel.scrollLeft;
        }

        function stopDragging() {
            isDown = false;
            eventsCarousel.classList.remove('dragging');
        }

        function drag(e) {
            if (!isDown) return;
            e.preventDefault();
            const x = (e.pageX || e.touches[0].pageX) - eventsCarousel.offsetLeft;
            const walk = (x - startX) * 2;
            eventsCarousel.scrollLeft = scrollLeft - walk;
        }

        // Mouse events
        eventsCarousel.addEventListener('mousedown', startDragging);
        eventsCarousel.addEventListener('mouseleave', stopDragging);
        eventsCarousel.addEventListener('mouseup', stopDragging);
        eventsCarousel.addEventListener('mousemove', drag);

        // Touch events
        eventsCarousel.addEventListener('touchstart', startDragging);
        eventsCarousel.addEventListener('touchend', stopDragging);
        eventsCarousel.addEventListener('touchcancel', stopDragging);
        eventsCarousel.addEventListener('touchmove', drag);

        // --- Mouse Wheel Scrolling ---
        eventsCarousel.addEventListener('wheel', (e) => {
            if (e.deltaY !== 0) { // Prevent page scroll only for vertical wheel
                e.preventDefault();
                eventsCarousel.scrollLeft += e.deltaY;
            }
        });
    });
</script>



    <script src="https://dikidi.ru/assets/js/widget_record/widget2.min.js?v=1735141723"></script>
</body>
</html>
